//! Методы массивов: part 3

//? методы добавления элементов:

// push() - мутирующий, добавляет элементы в конец массива, возвращает длину нового массива
// unshift() - мутирующий, добавляет элементы в начало массива, возвращает длину нового массива
// pop() - мутирующий, удаляет элемент из конца массива, возвращает удаленный элемент
// shift() - мутирующий, удаляет элемент из начала массива, возвращает удаленный элемент

//? методы массивов
// метод map() - не мутирующий метод, нужен для создания нового массива на основании исходного массива
// forEach() - мутирующий метод, мы можем изменять элементы исходного массива, возвращает undefined
// filter() - не мутирующий (создает новый массив), возвращает массив элементов, которые удовлетворяют одному и более условиям
// find() - не мутирующий метод, возвращает первый элемент, удовлетворяющий условию
// reduce() - не мутирующий метод, возвращает новый массив. Принимает 2 аргумента - стрелочну функцию и начальное значение переменной.

// * slice() - не мутирующий метод (удаляет/вырезает элементы), который возвращает новый массив элементов. Принимает 2 параметра:
// - индекс элемента с которого отрезает
// - индекс элемента до котого отрезает (не включительно)

// * splice() - мутирующий метод для массивов (удаляет/вырезает элементы). Возвращает удаленные элементы. Принимает два параметра:
// - индекс откуда
// - количество вырезаемых элементов

// * sort() - мутирующий метод, сортирует элементы массива (учитывает регистр). Возвращает новый массив отсортированных элементов и сортирует исходный.
// что метод работал коректно с числами, ему нужно передать функцию сортировки .sort((a, b) => a - b)

// * join() - объединяет массиву в строку. Принимает параметр-разделитель, строковое значение

//? методы строк
// * split - не мутирующий метод для СТРОК. Вы передаете разделитель строку аргументом. Возвращает новый массив
// * slice() - работает для строк.
// - первый параметр - индекс с которого мы вырезаем (ВКЛЮЧИТЕЛЬНО)
// - второй параметр - индекс по который вырезаем (НЕ ВКЛЮЧИТЕЛЬНО)
//* toUppercase()
//* toLowerCase()
//* charAt()

const brothersFirstHalf = [
    { name: 'Frodo', height: 60, race: 'hobbit', age: 30, hasMagic: false },
    { name: 'Sam',  height: 62, race: 'hobbit', age: 29, hasMagic: false }
  ]

const brothersSecondHalf = [
    { name: 'Ghimli', height: 50, race: 'dwarf', age: 200, hasMagic: false },
    { name: 'Legolas', height: 190, race: 'elf', age: 500, hasMagic: true },
    { name: 'Aragorn', height: 180, race: 'human', age: 50, hasMagic: false }
  ]

//* вариант решения объединения массивов через spread оператор 
// const brother = [...brothersFirstHalf, ...brothersSecondHalf]
// const brotherInArray = [[...brothersFirstHalf], [...brothersSecondHalf]]

//* 1. concat() - не мутирующий метод, возвращает объединенный массив. Можно передавать несколько массивов в качестве аргументов для объединения.

const brothers = brothersFirstHalf.concat(brothersSecondHalf)

console.log(brothersFirstHalf)
console.log(brothers)

//* 2. includes() - возвращает булевое значение. Принимает значение и ищет его соответствие в массиве.
// через оператор && можно передать несколько значений
// не работает с ссылочными типами данных

const names = brothers.map(el => el.name)
console.log(names)

console.log(names.includes('Ghimli'))

//* 3. findIndex() - не мутирующий метод. Принимает стрелочную функцию и возвращает индекс первого элемента, который удовлетворяет условию.
//! если не один из элементов не удовлетворяет условию - вернет -1

console.log(names.findIndex(el => el === 'Ghimli'))
console.log(brothers.findIndex(el => el.name === 'Aragorn'))


// TODO Задача
// напишите функцию, которая принимает массив элементов и элемент, который нужно удалить из массива
// функция должна вернуть массив без удаленного элемента
// подумайте про то, чтобы если такого элемента в массиве нет - функция работала корректно
// если такого элемента нет - выведите в консоль (‘no such element in array’)

function deleteElementFromArray(arr, el) {
  const index = arr.findIndex(name => name === el)
  if (index !== -1) {
    arr.splice(index, 1)
    return arr
  }
  console.log('no such element in array');
  return arr
}

console.log(deleteElementFromArray(names, 'Sam'))


//? генерация случайных чисел - Math.random()
// Math.random() - возвращает случайное число с плавающей точкой от 0 до 1
// Math.floor() - округляет до ближайшего целого числа вниз

// хотим получить случайное число от 1 до 100

console.log(Math.random())
console.log(Math.random() * 100) // получим случайное число умноженное на 100 с плавующей точкой
console.log(Math.floor(Math.random() * 100)) // округляем, но можем получить 0 и не получим 100
console.log(Math.floor(Math.random() * 100) + 1) // чтобы не включить 0 и включить 100 - прибовляем 1


//* replace() - метод только для СТРОК. Заменяет подстроку в строке.
// - принимает что будет изменять первым элементом
// - вторым элементом принимает - на что будем изменять
//! вернет массив неизменным, если не получится найти подстроку

names.push('Ghimli')
// получаем большую строку
const namesStr = names.join(', ')
console.log(namesStr)

// заменяем только первое вхождение строки
console.log(namesStr.replace('Ghimli', 'GHIMLI'))

// используя регулярное выражение / /g - изменяем все вхождения
console.log(namesStr.replace(/Ghimli/g, 'GHIMLI'))